<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Chinese-Thai Flashcard App</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" rel="stylesheet">
    
    <style>
        /* --- CORE LAYOUT & APPEARANCE --- */
        html, body, #root {
            height: 100%;
            overflow: hidden;
        }
        .animated-bg {
            background: linear-gradient(-45deg, #667eea, #764ba2, #f093fb, #f5576c, #4facfe, #00f2fe);
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
        }
        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .flashcard-page {
            display: flex;
            flex-direction: column;
            height: 100vh;
            height: 100dvh;
            padding: 1rem;
        }
        .top-nav { flex-shrink: 0; }
        .card-scene-wrapper {
            flex-grow: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        .card-scene {
            width: min(85vw, 380px);
            height: min(70vh, 520px);
            perspective: 1200px;
            position: relative;
        }

        /* --- Card & Flip Animation --- */
        .card-container {
            position: absolute;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            transition: transform 0.7s cubic-bezier(0.4, 0.0, 0.2, 1);
        }
        .card-container.flipped {
            transform: rotateY(180deg);
        }
        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            border-radius: 20px;
            background-color: #fdfdfd; /* Opaque background */
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        .card-back { transform: rotateY(180deg); }
        .card-back::before {
            content: '';
            position: absolute;
            top: 2px; left: 2px; right: 2px; bottom: 2px;
            background: #e0e0e0;
            transform: translateZ(-2px);
            border-radius: 18px;
        }

        /* --- Card Stack & Swipe Animation --- */
        .card-stack-item {
            position: absolute;
            width: 100%;
            height: 100%;
            transition: transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1), opacity 0.4s;
            touch-action: none;
        }
        .card-stack-item[data-index="0"] { z-index: 3; }
        .card-stack-item[data-index="1"] {
            transform: scale(0.9) translateY(-30px);
            z-index: 2;
        }
        .card-stack-item[data-index="2"] {
            transform: scale(0.8) translateY(-60px);
            opacity: 0.5; /* Make it slightly visible but not distracting */
            z-index: 1;
        }

        /* --- Card Content & UI Elements --- */
        .card-content {
            width: 100%;
            padding: clamp(16px, 5vw, 28px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            gap: 1rem;
        }
        .chinese-character { font-size: clamp(2.5rem, 8vw, 4rem); font-weight: 400; color: #1f2937; cursor: pointer; user-select: none; }
        .pinyin { font-size: clamp(1.2rem, 4vw, 1.6rem); color: #6b7280; cursor: pointer; user-select: none; }
        .emoji-display { font-size: clamp(2.5rem, 7vw, 3.5rem); }
        .english-translation { font-size: clamp(1.2rem, 4vw, 1.5rem); font-weight: 500; color: #374151; cursor: pointer; user-select: none; }
        .thai-translation { font-size: clamp(1.1rem, 3.5vw, 1.3rem); color: #6b7280; cursor: pointer; user-select: none; }
        .mobile-button { background: none; border: none; padding: 8px; color: white; opacity: 0.8; transition: all 0.2s ease; }
        .mobile-button:active { transform: scale(0.9); opacity: 1; }
        
        /* --- MODIFIED: Collection Page Layout --- */
        .collection-page {
            display: flex;
            flex-direction: column;
            height: 100vh;
            height: 100dvh;
            padding: 1rem;
            overflow: hidden; /* No scrollbars */
        }
        .collection-grid {
            flex-grow: 1;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            grid-template-rows: repeat(3, 1fr); /* 3 rows */
            gap: 1rem;
            padding-top: 1rem;
        }
        .small-card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
            padding: 0.5rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            color: #374151;
            font-size: 0.7rem;
            line-height: 1.3;
        }
        /* --- MODIFIED: Remembered Card Text Hierarchy --- */
        .small-card .chinese-character { font-size: 1.5rem; font-weight: 500; margin-bottom: 0.1rem; }
        .small-card .pinyin { font-size: 0.8rem; margin-bottom: 0.4rem; color: #6b7280; }
        .small-card .emoji-display { font-size: 1.1rem; margin-top: 0.2rem; }
        .small-card .english-translation { font-size: 0.8rem; font-weight: 500; }
        .small-card .thai-translation { font-size: 0.75rem; color: #6b7280; }

        .flippable-small-card {
            perspective: 800px;
        }
        .flippable-small-card .card-container {
            transition-duration: 0.6s;
        }
        
        /* Other styles */
        .slide-container{position:relative;width:100%;max-width:300px;height:50px;background-color:rgba(255,255,255,0.2);border-radius:25px;overflow:hidden;box-shadow:inset 0 0 10px rgba(0,0,0,0.1)}.slide-text{position:absolute;width:100%;height:100%;display:flex;align-items:center;justify-content:center;color:rgba(255,255,255,0.8);font-weight:bold;font-size:1rem;pointer-events:none;transition:opacity .3s ease}.slide-button{width:50px;height:50px;background:linear-gradient(135deg,#00f2fe,#4facfe);border-radius:50%;position:absolute;left:0;top:0;display:flex;align-items:center;justify-content:center;cursor:grab;box-shadow:0 5px 15px rgba(0,0,0,0.2);transition:transform .1s ease-out;touch-action:pan-x}.slide-button.unlocked{transform:translateX(calc(100% - 50px));cursor:auto}.slide-fill{height:100%;background:linear-gradient(90deg,#4facfe,#00f2fe);border-radius:25px;width:0;transition:width .1s ease-out}.modal-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,0.6);display:flex;align-items:center;justify-content:center;z-index:1000;opacity:0;visibility:hidden;transition:opacity .3s ease,visibility .3s ease}.modal-overlay.open{opacity:1;visibility:visible}.modal-content{background:linear-gradient(135deg,rgba(255,255,255,0.95) 0%,rgba(248,250,252,0.9) 100%);border-radius:20px;padding:30px;box-shadow:0 20px 40px rgba(0,0,0,0.2);max-width:90vw;width:400px;text-align:center;transform:translateY(-20px);opacity:0;transition:transform .3s ease,opacity .3s ease}.modal-overlay.open .modal-content{transform:translateY(0);opacity:1}.mobile-center{display:flex;align-items:center;justify-content:center;min-height:100vh;min-height:100dvh;width:100%;padding:16px;box-sizing:border-box}
    </style>
</head>
<body class="animated-bg font-sans text-gray-800">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // --- DATA & CONFIG ---
        const TRANSLATIONS={"en-US":{flashcardsCode:"Learn Chinese with Flashcards",slideToUnlock:"slide to unlock",pasteCodePlaceholder:"paste or type your unique code here...",createNewFlashcardsLink:"Enter new code",collection:"All Decks",backToStudy:"Back to Study",noCollectedCards:"No cards collected yet",rememberedCards:"Remembered Cards",forgottenCards:"Forgotten Cards",landingPageSubtitle:'Enter "LearnChinesewithHelen1295" or "PinyinPractice" to start.'}};
        const CHINESE_VOCABULARY=[{front:"Áà∏Áà∏\nb√† ba",back:"dad\n‡∏û‡πà‡∏≠",emoji:"üë®‚Äçüëß‚Äçüë¶"},{front:"Âà´\nbi√©",back:"don't\n‡∏≠‡∏¢‡πà‡∏≤",emoji:"üö´"},{front:"ÊúãÂèã\np√©ng y«íu",back:"friend\n‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô",emoji:"üë´"},{front:"ÊÄï\np√†",back:"to fear\n‡∏Å‡∏•‡∏±‡∏ß",emoji:"üò®"},{front:"Â¶àÂ¶à\nmƒÅ ma",back:"mom\n‡πÅ‡∏°‡πà",emoji:"üë©‚Äçüëß‚Äçüë¶"},{front:"‰π∞\nm«éi",back:"to buy\n‡∏ã‡∏∑‡πâ‡∏≠",emoji:"üõí"},{front:"È•≠\nf√†n",back:"meal\n‡∏Ç‡πâ‡∏≤‡∏ß",emoji:"üçΩÔ∏è"},{front:"ÂØå\nf√π",back:"rich\n‡∏£‡∏ß‡∏¢",emoji:"üí∞"},{front:"Â•∂Â•∂\nn«éi nai",back:"grandmother\n‡∏¢‡∏≤‡∏¢",emoji:"üëµ"},{front:"‰Ω†\nn«ê",back:"you\n‡∏Ñ‡∏∏‡∏ì",emoji:"üë§"},{front:"ËÄÅ\nl«éo",back:"old\n‡πÅ‡∏Å‡πà",emoji:"üßì"},{front:"Êù•\nl√°i",back:"to come\n‡∏°‡∏≤",emoji:"‚û°Ô∏è"},{front:"Â§ß\nd√†",back:"big\n‡πÉ‡∏´‡∏ç‡πà",emoji:"üìè"},{front:"Âæó\nd√©",back:"to get\n‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö",emoji:"üèÜ"},{front:"Ë∑≥\nti√†o",back:"to jump\n‡∏Å‡∏£‡∏∞‡πÇ‡∏î‡∏î",emoji:"ü§∏"},{front:"Ë∞É\nti√°o",back:"to adjust\n‡∏õ‡∏£‡∏±‡∏ö",emoji:"‚öôÔ∏è"},{front:"Áå™\nzh≈´",back:"pig\n‡∏´‡∏°‡∏π",emoji:"üê∑"},{front:"‰Ωè\nzh√π",back:"to live\n‡∏≠‡∏≤‡∏®‡∏±‡∏¢",emoji:"üè†"},{front:"ÂêÉ\nchƒ´",back:"to eat\n‡∏Å‡∏¥‡∏ô",emoji:"üçΩÔ∏è"},{front:"Âá∫\nch≈´",back:"to go out\n‡∏≠‡∏≠‡∏Å‡πÑ‡∏õ",emoji:"üö™"},{front:"È´ò\ngƒÅo",back:"high\n‡∏™‡∏π‡∏á",emoji:"üìè"},{front:"‰∏™\ng√®",back:"measure word\n‡∏•‡∏±‡∏Å‡∏©‡∏ì‡∏ô‡∏≤‡∏°",emoji:"üìä"},{front:"Ë£§\nk√π",back:"trousers\n‡∏Å‡∏≤‡∏á‡πÄ‡∏Å‡∏á",emoji:"üëñ"},{front:"ÂèØ‰ª•\nkƒõ y«ê",back:"can\n‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ",emoji:"‚úÖ"},{front:"Ëôé\nh«î",back:"tiger\n‡πÄ‡∏™‡∏∑‡∏≠",emoji:"üêÖ"},{front:"Â•Ω\nh«éo",back:"good\n‡∏î‡∏µ",emoji:"üëç"},{front:"ÂÆ∂\njiƒÅ",back:"home\n‡∏ö‡πâ‡∏≤‡∏ô",emoji:"üè°"},{front:"Â∞±\nji√π",back:"then\n‡πÅ‡∏•‡πâ‡∏ß",emoji:"‚è≠Ô∏è"},{front:"Â∞è\nxi«éo",back:"small\n‡πÄ‡∏•‡πá‡∏Å",emoji:"üê≠"},{front:"ÂñúÊ¨¢\nx«ê huƒÅn",back:"to like\n‡∏ä‡∏≠‡∏ö",emoji:"‚ù§Ô∏è"}];
        const PINYIN_CARDS=[{front:"ang",back:"ang\nFinal compound: 'ahng' sound\n‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏™‡∏£‡∏∞‡∏ú‡∏™‡∏°: '‡∏≠‡∏≤‡∏á'",emoji:"üó£Ô∏è"},{front:"ing",back:"ing\nFinal compound: 'eeng' sound\n‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏™‡∏£‡∏∞‡∏ú‡∏™‡∏°: '‡∏≠‡∏¥‡∏á'",emoji:"üó£Ô∏è"},{front:"en",back:"en\nFinal compound: 'uhn' sound\n‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏™‡∏£‡∏∞‡∏ú‡∏™‡∏°: '‡πÄ‡∏≠‡∏¥‡∏ô'",emoji:"üó£Ô∏è"},{front:"ai",back:"ai\nFinal compound: 'eye' sound\n‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏™‡∏£‡∏∞‡∏ú‡∏™‡∏°: '‡πÑ‡∏≠'",emoji:"üó£Ô∏è"},{front:"ao",back:"ao\nFinal compound: 'aow' sound\n‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏™‡∏£‡∏∞‡∏ú‡∏™‡∏°: '‡πÄ‡∏≠‡∏≤'",emoji:"üó£Ô∏è"}];
        const ACCESS_CODES={LearnChinesewithHelen1295:{title:"Chinese Vocabulary",cards:CHINESE_VOCABULARY.map(card=>({...card,status:"new"})),sampleCard:{...CHINESE_VOCABULARY[0],status:"new"}},PinyinPractice:{title:"Pinyin Practice",cards:PINYIN_CARDS.map(card=>({...card,status:"new"})),sampleCard:{...PINYIN_CARDS[0],status:"new"}}};

        // --- UTILITY HOOKS & FUNCTIONS ---
        const useSpeech = () => {
            const [voices, setVoices] = useState([]);
            const [isReady, setIsReady] = useState(false);
            useEffect(() => {
                const loadVoices = () => {
                    const availableVoices = window.speechSynthesis.getVoices();
                    if (availableVoices.length > 0) {
                        setVoices(availableVoices);
                        setIsReady(true);
                        if (typeof speechSynthesis !== 'undefined' && speechSynthesis.onvoiceschanged !== undefined) {
                            speechSynthesis.onvoiceschanged = null;
                        }
                    }
                };
                loadVoices();
                if (typeof speechSynthesis !== 'undefined' && speechSynthesis.onvoiceschanged !== undefined) {
                    speechSynthesis.onvoiceschanged = loadVoices;
                }
                const voiceTimeout = setTimeout(loadVoices, 500);
                return () => {
                    clearTimeout(voiceTimeout);
                    if (typeof speechSynthesis !== 'undefined') {
                       speechSynthesis.cancel();
                    }
                };
            }, []);
            const pronounceText = useCallback((text, specificLang = null) => {
                if (!text || !text.trim() || typeof speechSynthesis === 'undefined' || !isReady) {
                    return;
                }
                speechSynthesis.cancel();
                setTimeout(() => {
                    const detectLanguage = (txt) => {
                        if (!txt) return 'en-US';
                        const cleanTxt = txt.trim();
                        if (/[\u4e00-\u9fff\u3400-\u4dbf]/.test(cleanTxt)) return 'zh-CN';
                        if (/[\u0e00-\u0e7f]/.test(cleanTxt)) return 'th-TH';
                        if (/[ƒÅ√°«é√†ƒì√©ƒõ√®ƒ´√≠«ê√¨≈ç√≥«í√≤≈´√∫«î√π«ñ«ò«ö«ú]/.test(cleanTxt)) return 'zh-CN';
                        return 'en-US';
                    };
                    const lang = specificLang || detectLanguage(text);
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.lang = lang;
                    let voice = null;
                    let rate = 0.8;
                    if (lang.startsWith('zh')) {
                        voice = voices.find(v => v.lang === 'zh-CN' && v.name.includes('Ting-Ting')) || voices.find(v => v.lang === 'zh-CN') || voices.find(v => v.lang.startsWith('zh'));
                        rate = 0.7;
                    } else if (lang.startsWith('th')) {
                        voice = voices.find(v => v.lang === 'th-TH') || voices.find(v => v.lang.startsWith('th'));
                        rate = 0.8;
                    } else {
                        voice = voices.find(v => v.lang === 'en-US') || voices.find(v => v.lang.startsWith('en'));
                    }
                    if (voice) utterance.voice = voice;
                    utterance.rate = rate;
                    speechSynthesis.speak(utterance);
                }, 50);
            }, [voices, isReady]);
            return { pronounceText };
        };
        const Modal = ({ isOpen, onClose, title, message, children }) => {
            if (!isOpen) return null;
            return React.createElement("div", { className: `modal-overlay ${isOpen ? 'open' : ''}`, onClick: onClose },
                React.createElement("div", { className: "modal-content", onClick: e => e.stopPropagation() },
                    title && React.createElement("h3", { className: "text-2xl font-bold mb-4 text-gray-800" }, title),
                    message && React.createElement("p", { className: "text-gray-700 mb-6" }, message),
                    children,
                    React.createElement("button", { onClick: onClose, className: "mt-4 px-6 py-3 bg-blue-500 text-white rounded-full shadow-lg hover:bg-blue-600 transition duration-300" }, "Close")
                )
            );
        };
        const SlideToUnlock = ({ onUnlock }) => {
            const sliderRef = useRef(null);
            const [isDragging, setIsDragging] = useState(false);
            const [currentX, setCurrentX] = useState(0);
            const [unlocked, setUnlocked] = useState(false);
            const [maxTranslateX, setMaxTranslateX] = useState(0);
            useEffect(() => {
                const calculateMaxTranslateX = () => {
                    if (sliderRef.current) {
                        setMaxTranslateX(sliderRef.current.offsetWidth - 50);
                    }
                };
                calculateMaxTranslateX();
                window.addEventListener('resize', calculateMaxTranslateX);
                return () => window.removeEventListener('resize', calculateMaxTranslateX);
            }, []);
            const handleStart = (clientX) => {
                if (unlocked) return;
                setIsDragging(true);
                sliderRef.current.startX = clientX;
            };
            const handleMove = (clientX) => {
                if (!isDragging || unlocked) return;
                const deltaX = clientX - sliderRef.current.startX;
                const newX = Math.max(0, Math.min(deltaX, maxTranslateX));
                setCurrentX(newX);
                if (newX >= maxTranslateX - 2) {
                    setUnlocked(true);
                    setIsDragging(false);
                    onUnlock();
                }
            };
            const handleEnd = () => {
                if (unlocked) return;
                if (isDragging) {
                    setIsDragging(false);
                    setCurrentX(0);
                }
            };
            return React.createElement("div", { ref: sliderRef, className: "slide-container", onMouseDown: (e) => handleStart(e.clientX), onMouseMove: (e) => handleMove(e.clientX), onMouseUp: handleEnd, onMouseLeave: handleEnd, onTouchStart: (e) => handleStart(e.touches[0].clientX), onTouchMove: (e) => handleMove(e.touches[0].clientX), onTouchEnd: handleEnd },
            React.createElement("div", { className: "slide-fill", style: { width: `${currentX + 25}px` } }),
            React.createElement("div", { className: `slide-button ${unlocked ? 'unlocked' : ''}`, style: { transform: `translateX(${currentX}px)` } }, unlocked ? React.createElement("i", { className: "fas fa-check" }) : React.createElement("i", { className: "fas fa-chevron-right" })),
            React.createElement("div", { className: `slide-text ${unlocked || currentX > 10 ? 'opacity-0' : 'opacity-100'}` }, TRANSLATIONS["en-US"].slideToUnlock));
        };
        
        // --- REBUILT: Main Flashcard Component ---
        const Flashcard = ({ card, onSwipe, index }) => {
            const [isFlipped, setIsFlipped] = useState(false);
            const cardRef = useRef(null);
            const touchState = useRef({ startX: 0, startY: 0, startTime: 0, isDragging: false, deltaX: 0 }).current;
            const { pronounceText } = useSpeech();

            useEffect(() => { setIsFlipped(false); }, [card]);

            const handlePointerDown = (e) => {
                touchState.isDragging = true;
                touchState.startX = e.clientX;
                touchState.startY = e.clientY;
                touchState.startTime = Date.now();
                cardRef.current.style.transition = 'none';
                e.target.setPointerCapture(e.pointerId);
            };

            const handlePointerMove = (e) => {
                if (!touchState.isDragging) return;
                touchState.deltaX = e.clientX - touchState.startX;
                const deltaY = e.clientY - touchState.startY;
                if (Math.abs(touchState.deltaX) < Math.abs(deltaY) && Date.now() - touchState.startTime > 100) {
                    touchState.isDragging = false;
                    return;
                }
                const rotation = touchState.deltaX * 0.1;
                cardRef.current.style.transformOrigin = `50% ${window.innerHeight}px`;
                cardRef.current.style.transform = `translateX(${touchState.deltaX}px) rotate(${rotation}deg)`;
            };

            const handlePointerUp = (e) => {
                if (!touchState.isDragging) return;
                touchState.isDragging = false;
                e.target.releasePointerCapture(e.pointerId);
                const touchDuration = Date.now() - touchState.startTime;

                if (touchDuration < 250 && Math.abs(touchState.deltaX) < 15) {
                    const isTextArea = e.target.closest('.chinese-character, .pinyin, .english-translation, .thai-translation');
                    if (!isTextArea) {
                        setIsFlipped(prev => !prev);
                    }
                } else {
                    const swipeThreshold = window.innerWidth * 0.35;
                    if (Math.abs(touchState.deltaX) > swipeThreshold) {
                        const direction = touchState.deltaX > 0 ? 'right' : 'left';
                        cardRef.current.style.transition = 'transform 0.4s';
                        cardRef.current.style.transform = `translateX(${direction === 'right' ? '200%' : '-200%'}) rotate(${direction === 'right' ? 45 : -45}deg)`;
                        setTimeout(() => onSwipe(direction), 100);
                    } else {
                       cardRef.current.style.transition = 'transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1)';
                       cardRef.current.style.transform = '';
                    }
                }
            };
            
            const handlePronounce = (e, text, lang) => {
                e.stopPropagation();
                pronounceText(text, lang);
            };

            const [chineseChar, pinyin] = card.front.split('\n').map(s => s.trim());
            const [englishTranslation, thaiTranslation] = card.back.split('\n').map(s => s.trim());

            return React.createElement("div", { ref: cardRef, className: "card-stack-item", "data-index": index, onPointerDown: handlePointerDown, onPointerMove: handlePointerMove, onPointerUp: handlePointerUp },
                React.createElement("div", { className: `card-container ${isFlipped ? 'flipped' : ''}` },
                    React.createElement("div", { className: "card-face" },
                        React.createElement("div", { className: "card-content" },
                            React.createElement("div", { className: "chinese-character", onClick: (e) => handlePronounce(e, chineseChar, 'zh-CN') }, chineseChar),
                            React.createElement("div", { className: "pinyin", onClick: (e) => handlePronounce(e, pinyin, 'zh-CN') }, pinyin),
                            React.createElement("div", { className: "emoji-display" }, card.emoji)
                        )
                    ),
                    React.createElement("div", { className: "card-face card-back" },
                        React.createElement("div", { className: "card-content" },
                            React.createElement("div", { className: "english-translation", onClick: (e) => handlePronounce(e, englishTranslation, 'en-US') }, englishTranslation),
                            React.createElement("div", { className: "thai-translation", onClick: (e) => handlePronounce(e, thaiTranslation, 'th-TH') }, thaiTranslation),
                            React.createElement("div", { className: "emoji-display" }, card.emoji)
                        )
                    )
                )
            );
        };
        
        // --- NEW: Flippable Small Card for Forgotten Section ---
        const FlippableSmallCard = ({ card, onLongPress }) => {
            const [isFlipped, setIsFlipped] = useState(false);
            const longPressTimeout = useRef(null);

            const handlePointerDown = () => {
                longPressTimeout.current = setTimeout(() => {
                    onLongPress(card);
                }, 500); // 500ms for long press
            };

            const handlePointerUp = () => {
                clearTimeout(longPressTimeout.current);
            };

            const handleClick = () => {
                setIsFlipped(true);
                setTimeout(() => setIsFlipped(false), 2000); // Flip back after 2s
            };

            const [chineseChar, pinyin] = card.front.split('\n').map(s => s.trim());
            const [englishTranslation, thaiTranslation] = card.back.split('\n').map(s => s.trim());

            return React.createElement("div", { 
                className: "flippable-small-card", 
                onClick: handleClick,
                onPointerDown: handlePointerDown,
                onPointerUp: handlePointerUp,
                onPointerLeave: handlePointerUp
            },
                React.createElement("div", { className: `card-container ${isFlipped ? 'flipped' : ''}` },
                    React.createElement("div", { className: "card-face small-card" },
                        React.createElement("div", { className: "chinese-character" }, chineseChar),
                        React.createElement("div", { className: "pinyin" }, pinyin),
                        React.createElement("div", { className: "emoji-display" }, card.emoji)
                    ),
                    React.createElement("div", { className: "card-face card-back small-card" },
                        React.createElement("div", { className: "english-translation" }, englishTranslation),
                        React.createElement("div", { className: "thai-translation" }, thaiTranslation)
                    )
                )
            );
        };
        
        // --- NEW: Static Small Card for Remembered Section ---
        const StaticSmallCard = ({ card }) => {
            const [chineseChar, pinyin] = card.front.split('\n').map(s => s.trim());
            const [englishTranslation, thaiTranslation] = card.back.split('\n').map(s => s.trim());
            return React.createElement("div", { className: "small-card" },
                React.createElement("div", { className: "chinese-character" }, chineseChar),
                React.createElement("div", { className: "pinyin" }, pinyin),
                React.createElement("div", { className: "english-translation" }, englishTranslation),
                React.createElement("div", { className: "thai-translation" }, thaiTranslation),
                React.createElement("div", { className: "emoji-display" }, card.emoji)
            );
        };

        const removeCardFromListByFront = (list, cardToRemove) => list.filter(c => c.front !== cardToRemove.front);

        const App = () => {
            const [currentPage, setCurrentPage] = useState('landing');
            const [deck, setDeck] = useState([]);
            const [visibleCards, setVisibleCards] = useState([]);
            const [rememberedCards, setRememberedCards] = useState([]);
            const [forgottenCards, setForgottenCards] = useState([]);
            const [showErrorModal, setShowErrorModal] = useState(false);
            const [errorMessage, setErrorMessage] = useState('');
            const [code, setCode] = useState('');

            const handleCodeUnlock = () => {
                const deckData = ACCESS_CODES[code];
                if (deckData) {
                    const initialDeck = deckData.cards.map(card => ({ ...card, status: 'new', level: 0, key: Math.random() }));
                    const shuffledDeck = [...initialDeck].sort(() => Math.random() - 0.5);
                    setDeck(shuffledDeck);
                    setVisibleCards(shuffledDeck.slice(0, 3));
                    setRememberedCards([]);
                    setForgottenCards([]);
                    setCurrentPage('flashcards');
                } else {
                    setErrorMessage("Invalid code. Please try again.");
                    setShowErrorModal(true);
                }
            };
            
            const handleSwipe = useCallback((direction) => {
                if (visibleCards.length === 0) return;
                const swipedCard = visibleCards[0];
                const newDeck = deck.slice(1);
                let nextRemembered = [...rememberedCards];
                let nextForgotten = [...forgottenCards];
                nextRemembered = removeCardFromListByFront(nextRemembered, swipedCard);
                nextForgotten = removeCardFromListByFront(nextForgotten, swipedCard);
                let deckUpdate = [...newDeck];
                if (direction === 'left') {
                    swipedCard.level = Math.max(0, swipedCard.level - 1);
                    nextForgotten.push(swipedCard);
                    const reinsertIndex = Math.min(5, deckUpdate.length);
                    deckUpdate.splice(reinsertIndex, 0, swipedCard);
                } else {
                    swipedCard.level += 1;
                    nextRemembered.push(swipedCard);
                    if (swipedCard.level < 2) {
                        deckUpdate.push(swipedCard);
                    }
                }
                setDeck(deckUpdate);
                setRememberedCards(nextRemembered);
                setForgottenCards(nextForgotten);
                setVisibleCards(deckUpdate.slice(0, 3));
            }, [deck, visibleCards, rememberedCards, forgottenCards]);

            const handleLongPress = (cardToStudy) => {
                const newDeck = [cardToStudy, ...deck.filter(c => c.key !== cardToStudy.key)];
                setDeck(newDeck);
                setVisibleCards(newDeck.slice(0, 3));
                setCurrentPage('flashcards');
            };

            const resetApp = () => {
                setCurrentPage('landing');
                setCode('');
                setDeck([]);
                setVisibleCards([]);
                setRememberedCards([]);
                setForgottenCards([]);
            };
            
            const CollectionPage = ({ title, cards, onBack, fallbackMessage, cardType }) => (
                React.createElement("div", { className: "collection-page" },
                    React.createElement("div", { className: "top-nav w-full flex justify-between items-center" },
                        React.createElement("button", { onClick: onBack, className: "mobile-button", title: TRANSLATIONS["en-US"].backToStudy }, React.createElement("i", { className: "fas fa-arrow-left text-2xl" })),
                        React.createElement("h2", { className: "text-2xl font-bold text-white" }, title),
                        React.createElement("div", { className: "w-12 h-12" })
                    ),
                    cards.length > 0 ? React.createElement("div", { className: "collection-grid" },
                        cards.slice(0, 6).map((card) => (
                           cardType === 'remembered' 
                           ? React.createElement(StaticSmallCard, { key: card.key, card: card })
                           : React.createElement(FlippableSmallCard, { key: card.key, card: card, onLongPress: handleLongPress })
                        ))
                    ) : React.createElement("div", {className: "flex-grow flex items-center justify-center"}, React.createElement("p", { className: "text-white text-center text-lg" }, fallbackMessage))
                )
            );
            const AllDecksPage=({title:e,decks:t,onBack:s})=>React.createElement("div",{className:"collection-page"},React.createElement("div",{className:"top-nav w-full flex justify-between items-center"},React.createElement("button",{onClick:s,className:"mobile-button",title:TRANSLATIONS["en-US"].backToStudy},React.createElement("i",{className:"fas fa-arrow-left text-2xl"})),React.createElement("h2",{className:"text-2xl font-bold text-white"},e),React.createElement("div",{className:"w-12 h-12"})),React.createElement("div",{className:"collection-grid"},t.map((e,t)=>React.createElement("div",{key:t,className:"small-card flex-col items-center justify-center p-2"},React.createElement("h4",{className:"font-bold text-base mb-2"},e.title),e.card?React.createElement(SmallCard,{card:e.card}):React.createElement("p",{className:"text-sm text-gray-500"},"No sample card")))));

            const renderContent = () => { 
                switch (currentPage) {
                    case 'landing':
                        return React.createElement("div",{className:"mobile-center flex-col p-4"},React.createElement("div",{className:"p-8 flex flex-col items-center gap-8 max-w-md w-full"},React.createElement("h1",{className:"text-3xl font-extrabold text-white text-center drop-shadow-lg"},TRANSLATIONS["en-US"].flashcardsCode),React.createElement("p",{className:"text-white text-lg text-center drop-shadow-md"},TRANSLATIONS["en-US"].landingPageSubtitle),React.createElement("input",{type:"text",placeholder:TRANSLATIONS["en-US"].pasteCodePlaceholder,className:"w-full p-3 rounded-xl bg-gray-100 bg-opacity-70 border border-gray-200 focus:outline-none focus:ring-2 focus:ring-blue-400 transition duration-200 text-center text-lg text-gray-800",value:code,onChange:e=>setCode(e.target.value)}),React.createElement(SlideToUnlock,{onUnlock:handleCodeUnlock})));
                    case 'flashcards':
                        if (visibleCards.length === 0) {
                            return (
                                <div className="mobile-center flex-col p-4">
                                    <div className="watercolor-card p-8 flex flex-col items-center gap-6 max-w-md w-full text-center">
                                        <h2 className="text-2xl font-bold text-gray-900">Deck Completed!</h2>
                                        <p className="text-gray-700">You've gone through all the cards in this deck.</p>
                                        <button onClick={resetApp} className="px-6 py-3 bg-blue-500 text-white rounded-full shadow-lg hover:bg-blue-600 transition duration-300">
                                            {TRANSLATIONS["en-US"].createNewFlashcardsLink}
                                        </button>
                                        <button onClick={() => setCurrentPage('allDecks')} className="mt-2 px-6 py-3 bg-purple-500 text-white rounded-full shadow-lg hover:bg-purple-600 transition duration-300">
                                            View All Decks
                                        </button>
                                    </div>
                                </div>
                            );
                        }

                        return (
                            <div className="flashcard-page">
                                <div className="top-nav w-full flex justify-end items-center space-x-2 sm:space-x-4">
                                    <button onClick={() => setCurrentPage('remembered')} className="mobile-button" title={TRANSLATIONS["en-US"].rememberedCards}><i className="fas fa-check-double text-2xl"></i></button>
                                    <button onClick={() => setCurrentPage('forgotten')} className="mobile-button" title={TRANSLATIONS["en-US"].forgottenCards}><i className="fas fa-question text-2xl"></i></button>
                                    <button onClick={() => setCurrentPage('allDecks')} className="mobile-button" title={TRANSLATIONS["en-US"].collection}><i className="fas fa-layer-group text-2xl"></i></button>
                                    <button onClick={resetApp} className="mobile-button" title={TRANSLATIONS["en-US"].createNewFlashcardsLink}><i className="fas fa-undo text-2xl"></i></button>
                                </div>

                                <div className="card-scene-wrapper">
                                    <div className="card-scene">
                                        {visibleCards.map((card, index) => (
                                            <Flashcard 
                                                key={card.key} 
                                                card={card} 
                                                onSwipe={handleSwipe} 
                                                index={index} 
                                            />
                                        )).reverse()}
                                    </div>
                                </div>
                            </div>
                        );
                    case 'remembered':
                        return React.createElement(CollectionPage,{title:TRANSLATIONS["en-US"].rememberedCards,cards:rememberedCards,onBack:()=>setCurrentPage("flashcards"),fallbackMessage:TRANSLATIONS["en-US"].noCollectedCards, cardType: 'remembered'});
                    case 'forgotten':
                        return React.createElement(CollectionPage,{title:TRANSLATIONS["en-US"].forgottenCards,cards:forgottenCards,onBack:()=>setCurrentPage("flashcards"),fallbackMessage:TRANSLATIONS["en-US"].noCollectedCards, cardType: 'forgotten'});
                    case 'allDecks':
                        const allDeckItems = Object.keys(ACCESS_CODES).map(codeKey => ({ title: ACCESS_CODES[codeKey].title, card: ACCESS_CODES[codeKey].sampleCard }));
                        return React.createElement(AllDecksPage,{title:TRANSLATIONS["en-US"].collection,decks:allDeckItems,onBack:()=>setCurrentPage("flashcards")});
                    default:
                        return null;
                }
            };

            return (
                <div className="h-full">
                    {renderContent()}
                    <Modal isOpen={showErrorModal} onClose={() => setShowErrorModal(false)} title="Error" message={errorMessage} />
                </div>
            );
        };

        ReactDOM.render(React.createElement(App), document.getElementById('root'));
    </script>
</body>
</html>
" and the user query "here are some bugs after update:
1. when card flipping, it doesnt show thai and english translation
2. when click chinese and pinyin, it doesnt trigger pronounciation
3. blank content on forgotten cards page and bad ui design
4. crowded text content on each card at the remembered section. try to make the chinese and pinyin as the bigger text, and keep thai and english readable" to answer the user's query.

I have selected some code from the most up-to-date Canvas "Chinese-Thai Flashcard App (Final Polish)" document above and am asking a query about/based on this code.
Instructions to follow:
  * Don't output/edit the document if the query is Direct/Simple. For example, if the query asks for a simple explanation, output a direct answer.
  * Make sure to **edit** the document if the query shows the intent of editing the document, in which case output the entire edited document, **not just that section or the edits**.
    * Don't output the same document/empty document and say that you have edited it.
    * Don't change unrelated code in the document.
  * Don't output  and  in your final response.
  * Any references like "this" or "selected code" refers to the code between  and  tags.
  * Just acknowledge my request in the introduction.
  * Make sure to refer to the document as "Canvas" in your response.

here are some bugs after update:
1. when card flipping, it doesnt show thai and english translation
2. when click chinese and pinyin, it doesnt trigger pronounciation
3. blank content on forgotten cards page and bad ui design
4. crowded text content on each card at the remembered section. try to make the chinese and pinyin as the bigger text, and keep thai and english reada
